<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/python/avg_speed_plot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/python/avg_speed_plot.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;import re&#10;from pathlib import Path&#10;from typing import List, Tuple&#10;&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;def parse_time_speed(lines: List[str]) -&gt; Tuple[np.ndarray, np.ndarray]:&#10;    &quot;&quot;&quot;从原始行解析时间和速度数组。行格式示例: &quot;1值 4.2883&quot;。&#10;    返回按时间升序排序后的 t, v (ndarray)。&quot;&quot;&quot;&#10;    pattern = re.compile(r&quot;^\s*(\d+)\s*值\s*([+-]?\d+(?:\.?\d*)?)\s*$&quot;)&#10;    t_list: List[float] = []&#10;    v_list: List[float] = []&#10;    for line in lines:&#10;        if not line.strip():&#10;            continue&#10;        m = pattern.match(line)&#10;        if not m:&#10;            continue&#10;        t_list.append(float(m.group(1)))&#10;        v_list.append(float(m.group(2)))&#10;    if not t_list:&#10;        raise ValueError(&quot;未从数据中解析到任何(时间,速度)对&quot;)&#10;&#10;    t_arr = np.array(t_list, dtype=float)&#10;    v_arr = np.array(v_list, dtype=float)&#10;    order = np.argsort(t_arr)&#10;    return t_arr[order], v_arr[order]&#10;&#10;&#10;def group_mean_by_window(t: np.ndarray, v: np.ndarray, window: int = 20) -&gt; Tuple[np.ndarray, np.ndarray]:&#10;    &quot;&quot;&quot;按窗口大小分组并取时间/速度均值，末尾不足窗口照样取均值。&quot;&quot;&quot;&#10;    if window &lt;= 1 or len(t) != len(v):&#10;        return t, v&#10;    n = len(t)&#10;    groups = (n + window - 1) // window&#10;    t_means = np.empty(groups, dtype=float)&#10;    v_means = np.empty(groups, dtype=float)&#10;    for i in range(groups):&#10;        s = i * window&#10;        e = min((i + 1) * window, n)&#10;        t_means[i] = float(np.mean(t[s:e]))&#10;        v_means[i] = float(np.mean(v[s:e]))&#10;    return t_means, v_means&#10;&#10;&#10;def plot_avg_speed(t_avg: np.ndarray, v_avg: np.ndarray, out_path: Path) -&gt; None:&#10;    # 中文字体设置&#10;    try:&#10;        plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;Microsoft YaHei&quot;, &quot;SimHei&quot;, &quot;Arial Unicode MS&quot;]&#10;        plt.rcParams[&quot;axes.unicode_minus&quot;] = False&#10;    except Exception:&#10;        pass&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 4))&#10;    ax.plot(t_avg, v_avg, lw=1.2)&#10;    ax.set_xlabel(&quot;时间&quot;)&#10;    ax.set_ylabel(&quot;速度&quot;)&#10;    ax.set_title(&quot;速度-时间曲线&quot;)&#10;    ax.grid(True, alpha=0.3)&#10;    fig.tight_layout()&#10;&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=1200)&#10;    plt.close(fig)&#10;&#10;&#10;def plot_acceleration(t: np.ndarray, v: np.ndarray, out_path: Path) -&gt; None:&#10;    # 中文字体设置&#10;    try:&#10;        plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;Microsoft YaHei&quot;, &quot;SimHei&quot;, &quot;Arial Unicode MS&quot;]&#10;        plt.rcParams[&quot;axes.unicode_minus&quot;] = False&#10;    except Exception:&#10;        pass&#10;&#10;    # 计算加速度（速度变化率）&#10;    a = np.gradient(v, t)&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 4))&#10;    ax.plot(t, a, lw=1.2)&#10;    ax.set_xlabel(&quot;时间&quot;)&#10;    ax.set_ylabel(&quot;加速度&quot;)&#10;    ax.set_title(&quot;加速度-时间曲线&quot;)&#10;    ax.grid(True, alpha=0.3)&#10;    # 设置纵轴范围&#10;    ax.set_ylim(-0.01, 0.01)&#10;    fig.tight_layout()&#10;&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=1200)&#10;    plt.close(fig)&#10;&#10;&#10;def plot_all_metrics(t: np.ndarray, v: np.ndarray, t_smooth: np.ndarray, v_smooth: np.ndarray, a: np.ndarray, a_smooth: np.ndarray, out_path: Path) -&gt; None:&#10;    &quot;&quot;&quot;纵向排列三张子图：速度曲线（原始与平滑）、原始加速度、平滑加速度&quot;&quot;&quot;&#10;    try:&#10;        plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;Microsoft YaHei&quot;, &quot;SimHei&quot;, &quot;Arial Unicode MS&quot;]&#10;        plt.rcParams[&quot;axes.unicode_minus&quot;] = False&#10;    except Exception:&#10;        pass&#10;    # 创建三个子图，共享X轴&#10;    fig, axes = plt.subplots(3, 1, figsize=(10, 12), sharex=True)&#10;    # 速度曲线：原始与平滑&#10;    axes[0].plot(t, v, label=&quot;原始速度&quot;, color=&quot;C0&quot;, lw=1.2)&#10;    axes[0].plot(t_smooth, v_smooth, label=&quot;平滑速度&quot;, color=&quot;C1&quot;, lw=1.5)&#10;    axes[0].set_ylabel(&quot;速度&quot;)&#10;    axes[0].legend()&#10;    axes[0].grid(True, alpha=0.3)&#10;    # 原始加速度&#10;    axes[1].plot(t, a, label=&quot;原始加速度&quot;, color=&quot;C2&quot;, lw=1.2)&#10;    axes[1].set_ylabel(&quot;加速度&quot;)&#10;    axes[1].grid(True, alpha=0.3)&#10;    # 平滑加速度&#10;    axes[2].plot(t_smooth, a_smooth, label=&quot;平滑加速度&quot;, color=&quot;C3&quot;, lw=1.2)&#10;    axes[2].set_ylabel(&quot;加速度&quot;)&#10;    axes[2].set_xlabel(&quot;时间&quot;)&#10;    axes[2].set_ylim(-0.01, 0.01)&#10;    axes[2].grid(True, alpha=0.3)&#10;    fig.tight_layout()&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=1200)&#10;    plt.close(fig)&#10;&#10;&#10;def main() -&gt; None:&#10;    # 脚本所在目录&#10;    script_dir = Path(__file__).resolve().parent&#10;    data_file = script_dir / &quot;原始数据源(1s20000条).txt&quot;&#10;    out_file = script_dir / &quot;avg_speed.png&quot;&#10;&#10;    with open(data_file, encoding=&quot;utf-8&quot;) as f:&#10;        lines = f.readlines()&#10;&#10;    t, v = parse_time_speed(lines)&#10;    # 限制数据处理到前2000个点&#10;    t = t[:2000]&#10;    v = v[:2000]&#10;    # 计算平滑速度&#10;    t_smooth, v_smooth = group_mean_by_window(t, v, window=20)&#10;    # 直接计算原始加速度&#10;    a = np.gradient(v, t)&#10;    # 计算平滑加速度&#10;    a_smooth = np.gradient(v_smooth, t_smooth)&#10;&#10;    # 绘制并保存合并图像&#10;    combined_file = script_dir / &quot;combined_metrics.png&quot;&#10;    plot_all_metrics(t, v, t_smooth, v_smooth, a, a_smooth, combined_file)&#10;    print(f&quot;合并图像已保存: {combined_file}&quot;)&#10;&#10;    # 原有输出&#10;    print(f&quot;原始点数={len(v)}，加速度图像已保存: {script_dir / 'acceleration.png'}&quot;)&#10;    print(f&quot;图像已保存: {out_file}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="from __future__ import annotations&#10;import re&#10;from pathlib import Path&#10;from typing import List, Tuple&#10;&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;def parse_time_speed(lines: List[str]) -&gt; Tuple[np.ndarray, np.ndarray]:&#10;    &quot;&quot;&quot;从原始行解析时间和速度数组。行格式示例: &quot;1值 4.2883&quot;。&#10;    返回按时间升序排序后的 t, v (ndarray)。&quot;&quot;&quot;&#10;    pattern = re.compile(r&quot;^\s*(\d+)\s*值\s*([+-]?\d+(?:\.?\d*)?)\s*$&quot;)&#10;    t_list: List[float] = []&#10;    v_list: List[float] = []&#10;    for line in lines:&#10;        if not line.strip():&#10;            continue&#10;        m = pattern.match(line)&#10;        if not m:&#10;            continue&#10;        t_list.append(float(m.group(1)))&#10;        v_list.append(float(m.group(2)))&#10;    if not t_list:&#10;        raise ValueError(&quot;未从数据中解析到任何(时间,速度)对&quot;)&#10;&#10;    t_arr = np.array(t_list, dtype=float)&#10;    v_arr = np.array(v_list, dtype=float)&#10;    order = np.argsort(t_arr)&#10;    return t_arr[order], v_arr[order]&#10;&#10;&#10;def group_mean_by_window(t: np.ndarray, v: np.ndarray, window: int = 20) -&gt; Tuple[np.ndarray, np.ndarray]:&#10;    &quot;&quot;&quot;按窗口大小分组并取时间/速度均值，末尾不足窗口照样取均值。&quot;&quot;&quot;&#10;    if window &lt;= 1 or len(t) != len(v):&#10;        return t, v&#10;    n = len(t)&#10;    groups = (n + window - 1) // window&#10;    t_means = np.empty(groups, dtype=float)&#10;    v_means = np.empty(groups, dtype=float)&#10;    for i in range(groups):&#10;        s = i * window&#10;        e = min((i + 1) * window, n)&#10;        t_means[i] = float(np.mean(t[s:e]))&#10;        v_means[i] = float(np.mean(v[s:e]))&#10;    return t_means, v_means&#10;&#10;&#10;def plot_avg_speed(t_avg: np.ndarray, v_avg: np.ndarray, out_path: Path) -&gt; None:&#10;    # 中文字体设置&#10;    try:&#10;        plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;Microsoft YaHei&quot;, &quot;SimHei&quot;, &quot;Arial Unicode MS&quot;]&#10;        plt.rcParams[&quot;axes.unicode_minus&quot;] = False&#10;    except Exception:&#10;        pass&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 4))&#10;    ax.plot(t_avg, v_avg, lw=1.2)&#10;    ax.set_xlabel(&quot;时间&quot;)&#10;    ax.set_ylabel(&quot;速度&quot;)&#10;    ax.set_title(&quot;速度-时间曲线&quot;)&#10;    ax.grid(True, alpha=0.3)&#10;    fig.tight_layout()&#10;&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=1200)&#10;    plt.close(fig)&#10;&#10;&#10;def plot_acceleration(t: np.ndarray, v: np.ndarray, out_path: Path) -&gt; None:&#10;    # 中文字体设置&#10;    try:&#10;        plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;Microsoft YaHei&quot;, &quot;SimHei&quot;, &quot;Arial Unicode MS&quot;]&#10;        plt.rcParams[&quot;axes.unicode_minus&quot;] = False&#10;    except Exception:&#10;        pass&#10;&#10;    # 计算加速度（速度变化率）&#10;    a = np.gradient(v, t)&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 4))&#10;    ax.plot(t, a, lw=1.2)&#10;    ax.set_xlabel(&quot;时间&quot;)&#10;    ax.set_ylabel(&quot;加速度&quot;)&#10;    ax.set_title(&quot;加速度-时间曲线&quot;)&#10;    ax.grid(True, alpha=0.3)&#10;    # 设置纵轴范围&#10;    ax.set_ylim(-0.01, 0.01)&#10;    fig.tight_layout()&#10;&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=1200)&#10;    plt.close(fig)&#10;&#10;&#10;def plot_all_metrics(t: np.ndarray, v: np.ndarray, t_smooth: np.ndarray, v_smooth: np.ndarray, a: np.ndarray, a_smooth: np.ndarray, out_path: Path) -&gt; None:&#10;    &quot;&quot;&quot;纵向排列四张子图：原始速度、平滑速度、原始加速度、平滑加速度&quot;&quot;&quot;&#10;    try:&#10;        plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;Microsoft YaHei&quot;, &quot;SimHei&quot;, &quot;Arial Unicode MS&quot;]&#10;        plt.rcParams[&quot;axes.unicode_minus&quot;] = False&#10;    except Exception:&#10;        pass&#10;    # 创建四个子图，共享X轴&#10;    fig, axes = plt.subplots(4, 1, figsize=(10, 16), sharex=True)&#10;    &#10;    # 原始速度&#10;    axes[0].plot(t, v, color=&quot;C0&quot;, lw=1.2)&#10;    axes[0].set_ylabel(&quot;原始速度&quot;)&#10;    axes[0].set_title(&quot;原始速度-时间曲线&quot;)&#10;    axes[0].grid(True, alpha=0.3)&#10;    &#10;    # 平滑速度&#10;    axes[1].plot(t_smooth, v_smooth, color=&quot;C1&quot;, lw=1.5)&#10;    axes[1].set_ylabel(&quot;平滑速度&quot;)&#10;    axes[1].set_title(&quot;平滑速度-时间曲线（每20点平均）&quot;)&#10;    axes[1].grid(True, alpha=0.3)&#10;    &#10;    # 原始加速度&#10;    axes[2].plot(t, a, color=&quot;C2&quot;, lw=1.2)&#10;    axes[2].set_ylabel(&quot;加速度&quot;)&#10;    axes[2].set_title(&quot;原始加速度-时间曲线&quot;)&#10;    axes[2].grid(True, alpha=0.3)&#10;    axes[2].set_ylim(-0.01, 0.01)&#10;    &#10;    # 平滑加速度&#10;    axes[3].plot(t_smooth, a_smooth, color=&quot;C3&quot;, lw=1.2)&#10;    axes[3].set_ylabel(&quot;加速度&quot;)&#10;    axes[3].set_xlabel(&quot;时间&quot;)&#10;    axes[3].set_title(&quot;平滑加速度-时间曲线&quot;)&#10;    axes[3].set_ylim(-0.01, 0.01)&#10;    axes[3].grid(True, alpha=0.3)&#10;    &#10;    fig.tight_layout()&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=1200)&#10;    plt.close(fig)&#10;&#10;&#10;def main() -&gt; None:&#10;    # 脚本所在目录&#10;    script_dir = Path(__file__).resolve().parent&#10;    data_file = script_dir / &quot;原始数据源(1s20000条).txt&quot;&#10;    out_file = script_dir / &quot;avg_speed.png&quot;&#10;&#10;    with open(data_file, encoding=&quot;utf-8&quot;) as f:&#10;        lines = f.readlines()&#10;&#10;    t, v = parse_time_speed(lines)&#10;    # 限制数据处理到前2000个点&#10;    t = t[:2000]&#10;    v = v[:2000]&#10;    # 计算平滑速度&#10;    t_smooth, v_smooth = group_mean_by_window(t, v, window=20)&#10;    # 直接计算原始加速度&#10;    a = np.gradient(v, t)&#10;    # 计算平滑加速度&#10;    a_smooth = np.gradient(v_smooth, t_smooth)&#10;&#10;    # 绘制并保存合并图像&#10;    combined_file = script_dir / &quot;combined_metrics.png&quot;&#10;    plot_all_metrics(t, v, t_smooth, v_smooth, a, a_smooth, combined_file)&#10;    print(f&quot;合并图像已保存: {combined_file}&quot;)&#10;&#10;    # 原有输出&#10;    print(f&quot;原始点数={len(v)}，加速度图像已保存: {script_dir / 'acceleration.png'}&quot;)&#10;    print(f&quot;图像已保存: {out_file}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/python/filter_and_accel_plot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/python/filter_and_accel_plot.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;filter_and_accel_plot.py&#10;&#10;对原始速度数据应用多种滤波方法，计算加速度并绘图。&#10;图像保存在 python/ 目录下。&#10;&quot;&quot;&quot;&#10;import re&#10;from pathlib import Path&#10;from typing import List, Tuple&#10;&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;# 可选：使用 Savitzky-Golay 滤波&#10;try:&#10;    from scipy.signal import savgol_filter&#10;except ImportError:&#10;    savgol_filter = None  # 如果没有 scipy，可跳过此方法&#10;&#10;&#10;def parse_time_speed(lines: List[str]) -&gt; Tuple[np.ndarray, np.ndarray]:&#10;    &quot;&quot;&quot;解析行, 返回排序后的时间(t)和速度(v)数组&quot;&quot;&quot;&#10;    pattern = re.compile(r&quot;^\s*(\d+)\s*值\s*([+-]?[0-9]+(?:\.[0-9]*)?)\s*$&quot;)&#10;    t_list, v_list = [], []&#10;    for line in lines:&#10;        m = pattern.match(line)&#10;        if m:&#10;            t_list.append(float(m.group(1)))&#10;            v_list.append(float(m.group(2)))&#10;    t_arr = np.array(t_list, dtype=float)&#10;    v_arr = np.array(v_list, dtype=float)&#10;    order = np.argsort(t_arr)&#10;    return t_arr[order], v_arr[order]&#10;&#10;&#10;def moving_average(v: np.ndarray, window: int = 20) -&gt; np.ndarray:&#10;    &quot;&quot;&quot;简单滑动平均&quot;&quot;&quot;&#10;    if window &lt; 1:&#10;        return v&#10;    kernel = np.ones(window) / window&#10;    return np.convolve(v, kernel, mode='same')&#10;&#10;&#10;def median_filter(v: np.ndarray, window: int = 21) -&gt; np.ndarray:&#10;    &quot;&quot;&quot;中位数滤波&quot;&quot;&quot;&#10;    if window &lt; 1 or window % 2 == 0:&#10;        return v&#10;    k = window // 2&#10;    v_padded = np.pad(v, k, mode='edge')&#10;    out = np.empty_like(v)&#10;    for i in range(len(v)):&#10;        out[i] = np.median(v_padded[i:i+window])&#10;    return out&#10;&#10;&#10;def plot_acceleration(t: np.ndarray, a: np.ndarray, title: str, out_path: Path) -&gt; None:&#10;    &quot;&quot;&quot;绘制加速度曲线并保存&quot;&quot;&quot;&#10;    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei', 'SimHei', 'Arial Unicode MS']&#10;    plt.rcParams['axes.unicode_minus'] = False&#10;    fig, ax = plt.subplots(figsize=(10, 4))&#10;    ax.plot(t, a, lw=1.2)&#10;    ax.set_xlabel('时间')&#10;    ax.set_ylabel('加速度')&#10;    ax.set_title(title)&#10;    ax.grid(True, alpha=0.3)&#10;    ax.set_ylim(-0.01, 0.01)&#10;    fig.tight_layout()&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;    fig.savefig(out_path, dpi=600)&#10;    plt.close(fig)&#10;&#10;&#10;def main():&#10;    root = Path(__file__).resolve().parents[1]&#10;    data_file = root / '原始数据源(1s20000条).txt'&#10;    lines = data_file.read_text(encoding='utf-8').splitlines()&#10;    t, v = parse_time_speed(lines)&#10;&#10;    # 定义滤波方案&#10;    filters = []&#10;    filters.append(('moving_avg20', moving_average(v, window=20)))&#10;    filters.append(('median21', median_filter(v, window=21)))&#10;    if savgol_filter is not None:&#10;        filters.append(('savgol21_3', savgol_filter(v, window_length=21, polyorder=3)))&#10;&#10;    # 对每种滤波结果计算加速度并绘图&#10;    for name, v_filt in filters:&#10;        a = np.gradient(v_filt, t)&#10;        out_file = Path(__file__).resolve().parent / f'acc_{name}.png'&#10;        plot_acceleration(t, a, f'加速度-时间曲线（{name}滤波）', out_file)&#10;        print(f'滤波 {name} 完成, 输出: {out_file}')&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>